/*******************************************************************************
* Copyright (C) 2016-2020 Advanced Micro Devices, Inc. All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell cop-
* ies of the Software, and to permit persons to whom the Software is furnished
* to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IM-
* PLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
* COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNE-
* CTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*******************************************************************************/

/**************************************************
* This file was generated by Tensile:             *
* https://github.com/ROCmSoftwarePlatform/Tensile *
**************************************************/


#include "Kernels.h"
extern "C"
__global__ void Cijk_AB_Copy_OptStride(
  tensile_half * dst,
  const tensile_half * src,
  unsigned int const strideO1J,
  unsigned int const strideOK,
  unsigned int const strideI1J,
  unsigned int const strideIK,
  unsigned int const size0I,
  unsigned int const size1J,
  unsigned int const sizeK)
{
/* hard-coded initial strides */
#define GLOBAL_O(IDX0I, IDX1J, IDXK) (( IDX0I + (IDX1J)*strideO1J + (IDXK)*strideOK ))
#define GLOBAL_I(IDX0I, IDX1J, IDXK) (( IDX0I + (IDX1J)*strideI1J + (IDXK)*strideIK ))
  if (hc_get_workitem_absolute_id(1) >=  size1J)
    return;

  unsigned int wgK = ( hc_get_group_id(2));
  unsigned int numThreads = hc_get_group_size(0);
  unsigned int global0I = ( hc_get_workitem_absolute_id(0));
  unsigned int global1J = ( hc_get_workitem_absolute_id(1));
  unsigned int elementsPerStore = 1;

  if(size0I * sizeof(tensile_half) > numThreads * sizeof(float4)){
    elementsPerStore = sizeof(float4)/sizeof(tensile_half);

    for(int i = 0; (i+1)*numThreads*elementsPerStore <= size0I ; i++){
      uint64_t idxO = GLOBAL_O( (uint64_t)(global0I+i*numThreads)*elementsPerStore, global1J, wgK);
      uint64_t idxI = GLOBAL_I( (uint64_t)(global0I+i*numThreads)*elementsPerStore, global1J, wgK);
      *((float4*)(dst+idxO)) = *((const float4*)(src+idxI));
    }
  }
  else if( size0I * sizeof(tensile_half) > numThreads * sizeof(float2)){
    elementsPerStore = sizeof(float2)/sizeof(tensile_half);

    for(int i = 0; (i+1)*numThreads*elementsPerStore <= size0I ; i++){
      uint64_t idxO = GLOBAL_O( (uint64_t)(global0I+i*numThreads)*elementsPerStore, global1J, wgK);
      uint64_t idxI = GLOBAL_I( (uint64_t)(global0I+i*numThreads)*elementsPerStore, global1J, wgK);
      *((float2*)(dst+idxO)) = *((const float2*)(src+idxI));
    }
  }

  //todo: handle edge

}
#undef GLOBAL_O
#undef GLOBAL_I
