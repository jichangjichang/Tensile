/*******************************************************************************
* Copyright (C) 2016-2020 Advanced Micro Devices, Inc. All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell cop-
* ies of the Software, and to permit persons to whom the Software is furnished
* to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IM-
* PLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
* COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNE-
* CTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*******************************************************************************/

/**************************************************
* This file was generated by Tensile:             *
* https://github.com/ROCmSoftwarePlatform/Tensile *
**************************************************/


#include "Kernels.h"
extern "C"
__global__ void Cijk_AB_Copy_OptStride(
  tensile_half * A_dst,
  const tensile_half * A_src,
  unsigned int const A_strideO1J,
  unsigned int const A_strideOK,
  unsigned int const A_strideI1J,
  unsigned int const A_strideIK,
  unsigned int const A_size0I,
  unsigned int const A_size1J,
  tensile_half * B_dst,
  const tensile_half * B_src,
  unsigned int const B_strideO1J,
  unsigned int const B_strideOK,
  unsigned int const B_strideI1J,
  unsigned int const B_strideIK,
  unsigned int const B_size0I,
  unsigned int const B_size1J,
  unsigned int const sizeK)
{
/* hard-coded initial strides */
#define A_GLOBAL_O(IDX0I, IDX1J, IDXK) (( IDX0I + (IDX1J)*A_strideO1J + (IDXK)*A_strideOK ))
#define A_GLOBAL_I(IDX0I, IDX1J, IDXK) (( IDX0I + (IDX1J)*A_strideI1J + (IDXK)*A_strideIK ))
#define B_GLOBAL_O(IDX0I, IDX1J, IDXK) (( IDX0I + (IDX1J)*B_strideO1J + (IDXK)*B_strideOK ))
#define B_GLOBAL_I(IDX0I, IDX1J, IDXK) (( IDX0I + (IDX1J)*B_strideI1J + (IDXK)*B_strideIK ))

  unsigned int wgK = ( hc_get_group_id(2));
  unsigned int numThreads = hc_get_group_size(0);
  unsigned int global0I = ( hc_get_workitem_absolute_id(0));
  unsigned int global1J = ( hc_get_workitem_absolute_id(1));
  unsigned int elementsPerStore = 1;

if (hc_get_workitem_absolute_id(1) <  A_size1J){
  if(A_size0I * sizeof(tensile_half) > numThreads * sizeof(float4)){
    elementsPerStore = sizeof(float4)/sizeof(tensile_half);

    for(int i = 0; (i+1)*numThreads*elementsPerStore <= A_size0I ; i++){
      uint64_t idxO = A_GLOBAL_O( (uint64_t)(global0I+i*numThreads)*elementsPerStore, global1J, wgK);
      uint64_t idxI = A_GLOBAL_I( (uint64_t)(global0I+i*numThreads)*elementsPerStore, global1J, wgK);
      *((float4*)(A_dst+idxO)) = *((const float4*)(A_src+idxI));
    }
  }
  else if( A_size0I * sizeof(tensile_half) > numThreads * sizeof(float2)){
    elementsPerStore = sizeof(float2)/sizeof(tensile_half);

    for(int i = 0; (i+1)*numThreads*elementsPerStore <= A_size0I ; i++){
      uint64_t idxO = A_GLOBAL_O( (uint64_t)(global0I+i*numThreads)*elementsPerStore, global1J, wgK);
      uint64_t idxI = A_GLOBAL_I( (uint64_t)(global0I+i*numThreads)*elementsPerStore, global1J, wgK);
      *((float2*)(A_dst+idxO)) = *((const float2*)(A_src+idxI));
    }
  }
}
if (hc_get_workitem_absolute_id(1) <  B_size1J){
  if(B_size0I * sizeof(tensile_half) > numThreads * sizeof(float4)){
    elementsPerStore = sizeof(float4)/sizeof(tensile_half);

    for(int i = 0; (i+1)*numThreads*elementsPerStore <= B_size0I ; i++){
      uint64_t idxO = B_GLOBAL_O( (uint64_t)(global0I+i*numThreads)*elementsPerStore, global1J, wgK);
      uint64_t idxI = B_GLOBAL_I( (uint64_t)(global0I+i*numThreads)*elementsPerStore, global1J, wgK);
      *((float4*)(B_dst+idxO)) = *((const float4*)(B_src+idxI));
    }
  }
  else if( B_size0I * sizeof(tensile_half) > numThreads * sizeof(float2)){
    elementsPerStore = sizeof(float2)/sizeof(tensile_half);

    for(int i = 0; (i+1)*numThreads*elementsPerStore <= B_size0I ; i++){
      uint64_t idxO = B_GLOBAL_O( (uint64_t)(global0I+i*numThreads)*elementsPerStore, global1J, wgK);
      uint64_t idxI = B_GLOBAL_I( (uint64_t)(global0I+i*numThreads)*elementsPerStore, global1J, wgK);
      *((float2*)(B_dst+idxO)) = *((const float2*)(B_src+idxI));
    }
  }
}
  //todo: handle edge

}
#undef A_GLOBAL_O
#undef A_GLOBAL_I
#undef B_GLOBAL_O
#undef B_GLOBAL_I
